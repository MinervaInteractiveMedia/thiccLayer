import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
import json
from datetime import datetime
import os

class PrinterConfig:
    """Configuration for specific 3D printer settings"""
    def __init__(self, config_file=None):
        # Default printer settings
        self.printer_name = "Generic Printer"
        self.bed_size_x = 200
        self.bed_size_y = 200
        self.bed_size_z = 200
        self.nozzle_temp = 200
        self.bed_temp = 60
        self.filament_diameter = 1.75
        self.retraction_distance = 5.0
        self.retraction_speed = 40
        self.travel_speed = 120
        self.print_speed = 50
        self.first_layer_speed = 20
        self.z_offset = 0.0
        self.use_bed_leveling = False
        self.bed_leveling_command = "G29"
        self.home_command = "G28"
        self.fan_speed = 255
        self.enable_fan_layer = 2
        
        if config_file:
            self.load_from_file(config_file)
    
    def load_from_file(self, filename):
        """Load printer configuration from JSON file"""
        try:
            with open(filename, 'r') as f:
                config = json.load(f)
                for key, value in config.items():
                    if hasattr(self, key):
                        setattr(self, key, value)
            return True
        except FileNotFoundError:
            messagebox.showwarning("Config Not Found", f"Config file {filename} not found. Using defaults.")
            return False
        except json.JSONDecodeError:
            messagebox.showerror("Invalid Config", f"Invalid JSON in {filename}. Using defaults.")
            return False
    
    def save_to_file(self, filename):
        """Save current configuration to JSON file"""
        config = {
            'printer_name': self.printer_name,
            'bed_size_x': self.bed_size_x,
            'bed_size_y': self.bed_size_y,
            'bed_size_z': self.bed_size_z,
            'nozzle_temp': self.nozzle_temp,
            'bed_temp': self.bed_temp,
            'filament_diameter': self.filament_diameter,
            'retraction_distance': self.retraction_distance,
            'retraction_speed': self.retraction_speed,
            'travel_speed': self.travel_speed,
            'print_speed': self.print_speed,
            'first_layer_speed': self.first_layer_speed,
            'z_offset': self.z_offset,
            'use_bed_leveling': self.use_bed_leveling,
            'bed_leveling_command': self.bed_leveling_command,
            'home_command': self.home_command,
            'fan_speed': self.fan_speed,
            'enable_fan_layer': self.enable_fan_layer
        }
        try:
            with open(filename, 'w') as f:
                json.dump(config, f, indent=2)
            return True
        except Exception as e:
            messagebox.showerror("Save Error", f"Could not save config: {str(e)}")
            return False

class GCodeGenerator:
    """Generate G-code from toolpath"""
    def __init__(self, printer_config):
        self.config = printer_config
        self.current_x = 0
        self.current_y = 0
        self.current_z = 0
        self.current_e = 0
        self.is_extruding = False
        
    def calculate_extrusion(self, distance, layer_height, extrusion_width, filament_diameter):
        """Calculate extrusion amount for a given distance"""
        line_volume = distance * extrusion_width * layer_height
        filament_radius = filament_diameter / 2
        filament_length = line_volume / (np.pi * filament_radius ** 2)
        return filament_length
    
    def generate_header(self, nozzle_diameter, layer_height, extrusion_width, pattern, shape):
        """Generate G-code header with printer initialization"""
        header = []
        header.append(f"; Generated by 3D Print Pattern Simulator")
        header.append(f"; Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        header.append(f"; Printer: {self.config.printer_name}")
        header.append(f"; Pattern: {pattern}")
        header.append(f"; Shape: {shape}")
        header.append(f"; Nozzle: {nozzle_diameter}mm")
        header.append(f"; Layer Height: {layer_height}mm")
        header.append(f"; Extrusion Width: {extrusion_width}mm")
        header.append("")
        header.append("; Start G-code")
        header.append("G21 ; Set units to millimeters")
        header.append("G90 ; Use absolute coordinates")
        header.append("M82 ; Use absolute distances for extrusion")
        header.append("")
        header.append(f"; Preheat")
        header.append(f"M140 S{self.config.bed_temp} ; Set bed temperature")
        header.append(f"M104 S{self.config.nozzle_temp} ; Set nozzle temperature")
        header.append(f"M190 S{self.config.bed_temp} ; Wait for bed temperature")
        header.append(f"M109 S{self.config.nozzle_temp} ; Wait for nozzle temperature")
        header.append("")
        header.append(f"; Homing and bed leveling")
        header.append(f"{self.config.home_command} ; Home all axes")
        if self.config.use_bed_leveling:
            header.append(f"{self.config.bed_leveling_command} ; Bed leveling")
        if self.config.z_offset != 0:
            header.append(f"G92 Z{self.config.z_offset} ; Set Z offset")
        header.append("")
        header.append("; Prime nozzle")
        header.append("G1 Z2.0 F3000 ; Move Z up")
        header.append("G1 X10 Y10 F5000 ; Move to start position")
        header.append("G1 Z0.3 F3000 ; Lower Z")
        header.append("G92 E0 ; Reset extruder")
        header.append("G1 X100 E15 F1000 ; Draw prime line")
        header.append("G1 Y10.4 F5000")
        header.append("G1 X10 E30 F1000 ; Draw second prime line")
        header.append("G92 E0 ; Reset extruder")
        header.append("G1 Z2.0 F3000 ; Move Z up")
        header.append("")
        
        return header
    
    def generate_footer(self):
        """Generate G-code footer with printer shutdown"""
        footer = []
        footer.append("")
        footer.append("; End G-code")
        footer.append("G91 ; Relative positioning")
        footer.append("G1 E-2 F2700 ; Retract filament")
        footer.append("G1 Z10 F3000 ; Raise Z")
        footer.append("G90 ; Absolute positioning")
        footer.append(f"G1 X0 Y{self.config.bed_size_y} F3000 ; Present print")
        footer.append("M106 S0 ; Turn off fan")
        footer.append("M104 S0 ; Turn off nozzle heater")
        footer.append("M140 S0 ; Turn off bed heater")
        footer.append("M84 ; Disable motors")
        footer.append("; Print complete!")
        
        return footer
    
    def move_to(self, x, y, z, feed_rate, extrude=False, layer_height=0.2, extrusion_width=0.4):
        """Generate G-code for a move"""
        bed_center_x = self.config.bed_size_x / 2
        bed_center_y = self.config.bed_size_y / 2
        
        actual_x = x + bed_center_x
        actual_y = y + bed_center_y
        actual_z = z
        
        distance = np.sqrt((actual_x - self.current_x)**2 + 
                          (actual_y - self.current_y)**2 + 
                          (actual_z - self.current_z)**2)
        
        gcode_lines = []
        
        if extrude and distance > 0.001:
            extrusion = self.calculate_extrusion(
                distance, layer_height, extrusion_width, self.config.filament_diameter
            )
            self.current_e += extrusion
            gcode_lines.append(
                f"G1 X{actual_x:.3f} Y{actual_y:.3f} Z{actual_z:.3f} "
                f"E{self.current_e:.5f} F{feed_rate*60:.0f}"
            )
        elif distance > 0.001:
            if self.is_extruding:
                self.current_e -= self.config.retraction_distance
                gcode_lines.append(f"G1 E{self.current_e:.5f} F{self.config.retraction_speed*60:.0f} ; Retract")
            
            gcode_lines.append(
                f"G0 X{actual_x:.3f} Y{actual_y:.3f} Z{actual_z:.3f} F{feed_rate*60:.0f}"
            )
            
            if extrude:
                self.current_e += self.config.retraction_distance
                gcode_lines.append(f"G1 E{self.current_e:.5f} F{self.config.retraction_speed*60:.0f} ; De-retract")
        
        self.current_x = actual_x
        self.current_y = actual_y
        self.current_z = actual_z
        self.is_extruding = extrude
        
        return gcode_lines

class PrintSimulator:
    def __init__(self, root):
        self.root = root
        self.root.title("3D Print Pattern Simulator with G-Code Export")
        self.root.geometry("1600x950")
        
        # Parameters
        self.nozzle_diameter = tk.DoubleVar(value=0.4)
        self.layer_height = tk.DoubleVar(value=0.2)
        self.extrusion_width = tk.DoubleVar(value=0.5)
        self.pattern_type = tk.StringVar(value="concentric")
        self.shape_type = tk.StringVar(value="cube")
        self.num_layers = tk.IntVar(value=20)
        self.infill_density = tk.DoubleVar(value=20)
        self.show_nozzle_path = tk.BooleanVar(value=True)
        self.show_extrusion = tk.BooleanVar(value=True)
        
        # Printer config
        self.printer_config = PrinterConfig()
        self.current_config_file = None
        
        self.setup_ui()
        self.update_visualization()
    
    def setup_ui(self):
        # Main container
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Left panel for controls
        control_frame = ttk.LabelFrame(main_frame, text="Parameters", padding=10)
        control_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))
        
        # Make control frame scrollable
        canvas = tk.Canvas(control_frame, width=280)
        scrollbar = ttk.Scrollbar(control_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Nozzle diameter
        ttk.Label(scrollable_frame, text="Nozzle Diameter (mm):").pack(anchor=tk.W)
        nozzle_slider = ttk.Scale(scrollable_frame, from_=0.2, to=2.0, 
                                  variable=self.nozzle_diameter, 
                                  command=lambda x: self.update_visualization(),
                                  orient=tk.HORIZONTAL, length=250)
        nozzle_slider.pack(fill=tk.X, pady=(0, 5))
        nozzle_label = ttk.Label(scrollable_frame, text="")
        nozzle_label.pack(anchor=tk.W)
        
        def update_nozzle_label(*args):
            nozzle_label.config(text=f"Value: {self.nozzle_diameter.get():.2f} mm")
        self.nozzle_diameter.trace_add('write', update_nozzle_label)
        update_nozzle_label()
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        
        # Layer height
        ttk.Label(scrollable_frame, text="Layer Height (mm):").pack(anchor=tk.W)
        layer_slider = ttk.Scale(scrollable_frame, from_=0.1, to=3.0, 
                                variable=self.layer_height,
                                command=lambda x: self.update_visualization(),
                                orient=tk.HORIZONTAL, length=250)
        layer_slider.pack(fill=tk.X, pady=(0, 5))
        layer_label = ttk.Label(scrollable_frame, text="")
        layer_label.pack(anchor=tk.W)
        
        def update_layer_label(*args):
            layer_label.config(text=f"Value: {self.layer_height.get():.2f} mm")
        self.layer_height.trace_add('write', update_layer_label)
        update_layer_label()
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        
        # Extrusion width
        ttk.Label(scrollable_frame, text="Extrusion Width (mm):").pack(anchor=tk.W)
        extrusion_slider = ttk.Scale(scrollable_frame, from_=0.3, to=3.0, 
                                     variable=self.extrusion_width,
                                     command=lambda x: self.update_visualization(),
                                     orient=tk.HORIZONTAL, length=250)
        extrusion_slider.pack(fill=tk.X, pady=(0, 5))
        extrusion_label = ttk.Label(scrollable_frame, text="")
        extrusion_label.pack(anchor=tk.W)
        
        def update_extrusion_label(*args):
            extrusion_label.config(text=f"Value: {self.extrusion_width.get():.2f} mm")
        self.extrusion_width.trace_add('write', update_extrusion_label)
        update_extrusion_label()
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        
        # Number of layers
        ttk.Label(scrollable_frame, text="Number of Layers:").pack(anchor=tk.W)
        layers_slider = ttk.Scale(scrollable_frame, from_=5, to=50, 
                                 variable=self.num_layers,
                                 command=lambda x: self.update_visualization(),
                                 orient=tk.HORIZONTAL, length=250)
        layers_slider.pack(fill=tk.X, pady=(0, 5))
        layers_label = ttk.Label(scrollable_frame, text="")
        layers_label.pack(anchor=tk.W)
        
        def update_layers_label(*args):
            layers_label.config(text=f"Value: {self.num_layers.get()}")
        self.num_layers.trace_add('write', update_layers_label)
        update_layers_label()
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        
        # Infill density
        ttk.Label(scrollable_frame, text="Infill Density (%):").pack(anchor=tk.W)
        infill_slider = ttk.Scale(scrollable_frame, from_=0, to=100, 
                                 variable=self.infill_density,
                                 command=lambda x: self.update_visualization(),
                                 orient=tk.HORIZONTAL, length=250)
        infill_slider.pack(fill=tk.X, pady=(0, 5))
        infill_label = ttk.Label(scrollable_frame, text="")
        infill_label.pack(anchor=tk.W)
        
        def update_infill_label(*args):
            infill_label.config(text=f"Value: {self.infill_density.get():.0f}%")
        self.infill_density.trace_add('write', update_infill_label)
        update_infill_label()
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        
        # Pattern type
        ttk.Label(scrollable_frame, text="Print Pattern:").pack(anchor=tk.W, pady=(5, 0))
        patterns = ["concentric", "rectilinear", "grid", "honeycomb", "hilbert", "spiral"]
        for pattern in patterns:
            ttk.Radiobutton(scrollable_frame, text=pattern.capitalize(), 
                          variable=self.pattern_type, value=pattern,
                          command=self.update_visualization).pack(anchor=tk.W)
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        
        # Shape type
        ttk.Label(scrollable_frame, text="Shape:").pack(anchor=tk.W, pady=(5, 0))
        shapes = ["cube", "cylinder", "pyramid", "vase", "flat_square"]
        for shape in shapes:
            ttk.Radiobutton(scrollable_frame, text=shape.replace("_", " ").capitalize(), 
                          variable=self.shape_type, value=shape,
                          command=self.update_visualization).pack(anchor=tk.W)
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        
        # Display options
        ttk.Label(scrollable_frame, text="Display Options:").pack(anchor=tk.W, pady=(5, 0))
        ttk.Checkbutton(scrollable_frame, text="Show Nozzle Path", 
                       variable=self.show_nozzle_path,
                       command=self.update_visualization).pack(anchor=tk.W)
        ttk.Checkbutton(scrollable_frame, text="Show Extrusion Volume", 
                       variable=self.show_extrusion,
                       command=self.update_visualization).pack(anchor=tk.W)
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        
        # Buttons
        ttk.Button(scrollable_frame, text="üîÑ Refresh Visualization", 
                  command=self.update_visualization).pack(pady=5, fill=tk.X)
        
        ttk.Button(scrollable_frame, text="üíæ Save Image", 
                  command=self.save_image).pack(pady=5, fill=tk.X)
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        
        # G-code section
        ttk.Label(scrollable_frame, text="G-Code Generation:", 
                 font=('TkDefaultFont', 10, 'bold')).pack(anchor=tk.W, pady=(5, 5))
        
        self.config_label = ttk.Label(scrollable_frame, text="Config: Generic Printer", 
                                      foreground='blue')
        self.config_label.pack(anchor=tk.W, pady=(0, 5))
        
        ttk.Button(scrollable_frame, text="üìÇ Load Printer Config", 
                  command=self.load_printer_config).pack(pady=2, fill=tk.X)
        
        ttk.Button(scrollable_frame, text="‚öôÔ∏è Edit Printer Settings", 
                  command=self.open_printer_settings).pack(pady=2, fill=tk.X)
        
        ttk.Button(scrollable_frame, text="üíæ Save Printer Config", 
                  command=self.save_printer_config).pack(pady=2, fill=tk.X)
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        
        ttk.Button(scrollable_frame, text="üñ®Ô∏è Generate G-Code", 
                  command=self.generate_gcode,
                  style='Accent.TButton').pack(pady=5, fill=tk.X)
        
        # Pack canvas and scrollbar
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Right panel for visualization
        viz_frame = ttk.Frame(main_frame)
        viz_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        
        # Create matplotlib figure
        self.fig = Figure(figsize=(10, 8))
        self.ax = self.fig.add_subplot(111, projection='3d')
        
        self.canvas = FigureCanvasTkAgg(self.fig, master=viz_frame)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Status bar
        self.status_bar = ttk.Label(self.root, text="Ready", relief=tk.SUNKEN)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
    
    def generate_path_points(self, shape, layer_z, pattern):
        """Generate toolpath points for a given layer"""
        points = []
        
        if shape == "flat_square" or shape == "cube":
            size = 40
            offset = size / 2
            
            if pattern == "concentric":
                num_rings = max(1, int(self.infill_density.get() / 10))
                for ring in range(num_rings):
                    s = size - ring * (size / (num_rings + 1))
                    o = s / 2
                    square_points = [
                        [-o, -o], [o, -o], [o, o], [-o, o], [-o, -o]
                    ]
                    for p in square_points:
                        points.append([p[0], p[1], layer_z])
            
            elif pattern == "rectilinear":
                spacing = self.extrusion_width.get() * (100 / max(1, self.infill_density.get()))
                num_lines = int(size / spacing)
                for i in range(num_lines):
                    y = -offset + i * spacing
                    if i % 2 == 0:
                        points.append([-offset, y, layer_z])
                        points.append([offset, y, layer_z])
                    else:
                        points.append([offset, y, layer_z])
                        points.append([-offset, y, layer_z])
            
            elif pattern == "grid":
                spacing = self.extrusion_width.get() * (100 / max(1, self.infill_density.get()))
                num_lines = int(size / spacing)
                for i in range(num_lines):
                    y = -offset + i * spacing
                    points.append([-offset, y, layer_z])
                    points.append([offset, y, layer_z])
                    points.append([np.nan, np.nan, np.nan])
                for i in range(num_lines):
                    x = -offset + i * spacing
                    points.append([x, -offset, layer_z])
                    points.append([x, offset, layer_z])
                    points.append([np.nan, np.nan, np.nan])
            
            elif pattern == "honeycomb":
                spacing = self.extrusion_width.get() * (100 / max(1, self.infill_density.get())) * 1.5
                for y in np.arange(-offset, offset, spacing * np.sqrt(3)/2):
                    row_offset = (int(y / spacing) % 2) * spacing / 2
                    for x in np.arange(-offset + row_offset, offset, spacing):
                        hex_points = []
                        for angle in np.linspace(0, 2*np.pi, 7):
                            hx = x + spacing/3 * np.cos(angle)
                            hy = y + spacing/3 * np.sin(angle)
                            if -offset <= hx <= offset and -offset <= hy <= offset:
                                hex_points.append([hx, hy, layer_z])
                        if hex_points:
                            points.extend(hex_points)
                            points.append([np.nan, np.nan, np.nan])
            
            elif pattern == "spiral":
                num_turns = max(1, int(self.infill_density.get() / 5))
                theta = np.linspace(0, num_turns * 2 * np.pi, 200)
                r = np.linspace(0, offset * 0.9, 200)
                for t, radius in zip(theta, r):
                    x = radius * np.cos(t)
                    y = radius * np.sin(t)
                    points.append([x, y, layer_z])
            
            elif pattern == "hilbert":
                def hilbert_curve(order, length):
                    if order == 0:
                        return [[0, 0]]
                    points = []
                    sub = hilbert_curve(order - 1, length / 2)
                    for p in sub:
                        points.append([p[1], p[0]])
                    for p in sub:
                        points.append([p[0], p[1] + length / 2])
                    for p in sub:
                        points.append([p[0] + length / 2, p[1] + length / 2])
                    for p in reversed(sub):
                        points.append([length / 2 - p[1], length / 2 - p[0]])
                    return points
                
                order = max(1, int(self.infill_density.get() / 25) + 1)
                curve = hilbert_curve(order, size * 0.9)
                for p in curve:
                    points.append([p[0] - offset * 0.9, p[1] - offset * 0.9, layer_z])
        
        elif shape == "cylinder":
            radius = 20
            if pattern == "concentric":
                num_rings = max(1, int(self.infill_density.get() / 10))
                for ring in range(num_rings):
                    r = radius * (1 - ring / (num_rings + 1))
                    theta = np.linspace(0, 2*np.pi, 100)
                    for t in theta:
                        points.append([r * np.cos(t), r * np.sin(t), layer_z])
            else:
                theta = np.linspace(0, 2*np.pi, 100)
                for t in theta:
                    points.append([radius * np.cos(t), radius * np.sin(t), layer_z])
        
        elif shape == "pyramid":
            size = 40
            layer_ratio = 1 - (layer_z / (self.num_layers.get() * self.layer_height.get()))
            current_size = size * layer_ratio
            offset = current_size / 2
            
            if current_size > 0:
                if pattern == "concentric":
                    square_points = [
                        [-offset, -offset], [offset, -offset], 
                        [offset, offset], [-offset, offset], [-offset, -offset]
                    ]
                    for p in square_points:
                        points.append([p[0], p[1], layer_z])
                else:
                    spacing = self.extrusion_width.get() * (100 / max(1, self.infill_density.get()))
                    num_lines = max(1, int(current_size / spacing))
                    for i in range(num_lines):
                        y = -offset + i * spacing
                        if i % 2 == 0:
                            points.append([-offset, y, layer_z])
                            points.append([offset, y, layer_z])
                        else:
                            points.append([offset, y, layer_z])
                            points.append([-offset, y, layer_z])
        
        elif shape == "vase":
            radius_base = 15
            radius_top = 25
            total_height = self.num_layers.get() * self.layer_height.get()
            t = layer_z / total_height
            radius = radius_base + (radius_top - radius_base) * t
            
            theta = np.linspace(0, 2*np.pi, 100)
            for angle in theta:
                points.append([radius * np.cos(angle), radius * np.sin(angle), layer_z])
        
        return np.array(points)
    
    def create_extrusion_geometry(self, p1, p2, width, height):
        """Create a rectangular extrusion between two points"""
        if np.any(np.isnan(p1)) or np.any(np.isnan(p2)):
            return None
        
        direction = p2 - p1
        length = np.linalg.norm(direction[:2])
        if length < 0.001:
            return None
        
        direction[:2] = direction[:2] / length
        perpendicular = np.array([-direction[1], direction[0], 0])
        
        w2 = width / 2
        h2 = height / 2
        
        v1 = p1 + perpendicular * w2 + np.array([0, 0, -h2])
        v2 = p1 - perpendicular * w2 + np.array([0, 0, -h2])
        v3 = p1 - perpendicular * w2 + np.array([0, 0, h2])
        v4 = p1 + perpendicular * w2 + np.array([0, 0, h2])
        
        v5 = p2 + perpendicular * w2 + np.array([0, 0, -h2])
        v6 = p2 - perpendicular * w2 + np.array([0, 0, -h2])
        v7 = p2 - perpendicular * w2 + np.array([0, 0, h2])
        v8 = p2 + perpendicular * w2 + np.array([0, 0, h2])
        
        vertices = [v1, v2, v3, v4, v5, v6, v7, v8]
        
        faces = [
            [vertices[0], vertices[1], vertices[5], vertices[4]],
            [vertices[2], vertices[3], vertices[7], vertices[6]],
            [vertices[0], vertices[4], vertices[7], vertices[3]],
            [vertices[1], vertices[2], vertices[6], vertices[5]],
            [vertices[0], vertices[3], vertices[2], vertices[1]],
            [vertices[4], vertices[5], vertices[6], vertices[7]],
        ]
        
        return faces
    
    def update_visualization(self):
        self.status_bar.config(text="Generating visualization...")
        self.root.update_idletasks()
        
        self.ax.clear()
        
        layer_height = self.layer_height.get()
        num_layers = self.num_layers.get()
        extrusion_width = self.extrusion_width.get()
        
        all_faces = []
        colors = []
        
        for layer_num in range(num_layers):
            layer_z = layer_num * layer_height
            points = self.generate_path_points(self.shape_type.get(), layer_z, self.pattern_type.get())
            
            if len(points) == 0:
                continue
            
            if self.show_nozzle_path.get():
                valid_points = points[~np.isnan(points).any(axis=1)]
                if len(valid_points) > 0:
                    self.ax.plot(valid_points[:, 0], valid_points[:, 1], valid_points[:, 2], 
                               'k-', linewidth=0.5, alpha=0.3)
            
            if self.show_extrusion.get():
                for i in range(len(points) - 1):
                    faces = self.create_extrusion_geometry(
                        points[i], points[i+1], extrusion_width, layer_height
                    )
                    if faces:
                        all_faces.extend(faces)
                        color_intensity = 0.3 + 0.7 * (layer_num / num_layers)
                        colors.extend([plt.cm.viridis(color_intensity)] * len(faces))
        
        if all_faces and self.show_extrusion.get():
            poly = Poly3DCollection(all_faces, facecolors=colors, 
                                   edgecolors='black', linewidths=0.1, alpha=0.8)
            self.ax.add_collection3d(poly)
        
        self.ax.set_xlabel('X (mm)')
        self.ax.set_ylabel('Y (mm)')
        self.ax.set_zlabel('Z (mm)')
        
        max_dim = 50
        self.ax.set_xlim([-max_dim, max_dim])
        self.ax.set_ylim([-max_dim, max_dim])
        self.ax.set_zlim([0, num_layers * layer_height])
        
        title = f"Pattern: {self.pattern_type.get()} | Shape: {self.shape_type.get()}\n"
        title += f"Nozzle: {self.nozzle_diameter.get():.2f}mm | "
        title += f"Layer: {layer_height:.2f}mm | "
        title += f"Extrusion: {extrusion_width:.2f}mm"
        self.ax.set_title(title)
        
        self.ax.view_init(elev=25, azim=45)
        
        self.canvas.draw()
        self.status_bar.config(text="Ready")
    
    def save_image(self):
        filename = filedialog.asksaveasfilename(
            defaultextension=".png",
            filetypes=[("PNG files", "*.png"), ("All files", "*.*")],
            initialfile=f"print_{self.pattern_type.get()}.png"
        )
        if filename:
            self.fig.savefig(filename, dpi=150, bbox_inches='tight')
            messagebox.showinfo("Success", f"Image saved to:\n{filename}")
    
    def load_printer_config(self):
        filename = filedialog.askopenfilename(
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            title="Load Printer Configuration"
        )
        if filename:
            if self.printer_config.load_from_file(filename):
                self.current_config_file = filename
                self.config_label.config(text=f"Config: {self.printer_config.printer_name}")
                messagebox.showinfo("Success", f"Loaded config: {self.printer_config.printer_name}")
    
    def save_printer_config(self):
        filename = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            initialfile="my_printer.json"
        )
        if filename:
            if self.printer_config.save_to_file(filename):
                self.current_config_file = filename
                messagebox.showinfo("Success", f"Configuration saved to:\n{filename}")
    
    def open_printer_settings(self):
        """Open printer settings dialog"""
        settings_window = tk.Toplevel(self.root)
        settings_window.title("Printer Settings")
        settings_window.geometry("500x700")
        
        # Create scrollable frame
        canvas = tk.Canvas(settings_window)
        scrollbar = ttk.Scrollbar(settings_window, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Settings fields
        settings = {}
        
        def add_setting(parent, label, var_name, current_value, var_type='float'):
            frame = ttk.Frame(parent)
            frame.pack(fill=tk.X, padx=10, pady=5)
            ttk.Label(frame, text=label, width=25).pack(side=tk.LEFT)
            if var_type == 'bool':
                var = tk.BooleanVar(value=current_value)
                ttk.Checkbutton(frame, variable=var).pack(side=tk.LEFT)
            else:
                var = tk.StringVar(value=str(current_value))
                ttk.Entry(frame, textvariable=var, width=20).pack(side=tk.LEFT)
            settings[var_name] = (var, var_type)
        
        ttk.Label(scrollable_frame, text="Printer Configuration", 
                 font=('TkDefaultFont', 12, 'bold')).pack(pady=10)
        
        add_setting(scrollable_frame, "Printer Name:", "printer_name", 
                   self.printer_config.printer_name, 'str')
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        ttk.Label(scrollable_frame, text="Build Volume (mm):", 
                 font=('TkDefaultFont', 10, 'bold')).pack(anchor=tk.W, padx=10)
        
        add_setting(scrollable_frame, "Bed Size X:", "bed_size_x", 
                   self.printer_config.bed_size_x, 'float')
        add_setting(scrollable_frame, "Bed Size Y:", "bed_size_y", 
                   self.printer_config.bed_size_y, 'float')
        add_setting(scrollable_frame, "Bed Size Z:", "bed_size_z", 
                   self.printer_config.bed_size_z, 'float')
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        ttk.Label(scrollable_frame, text="Temperatures:", 
                 font=('TkDefaultFont', 10, 'bold')).pack(anchor=tk.W, padx=10)
        
        add_setting(scrollable_frame, "Nozzle Temp (¬∞C):", "nozzle_temp", 
                   self.printer_config.nozzle_temp, 'int')
        add_setting(scrollable_frame, "Bed Temp (¬∞C):", "bed_temp", 
                   self.printer_config.bed_temp, 'int')
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        ttk.Label(scrollable_frame, text="Filament:", 
                 font=('TkDefaultFont', 10, 'bold')).pack(anchor=tk.W, padx=10)
        
        add_setting(scrollable_frame, "Filament Diameter (mm):", "filament_diameter", 
                   self.printer_config.filament_diameter, 'float')
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        ttk.Label(scrollable_frame, text="Retraction:", 
                 font=('TkDefaultFont', 10, 'bold')).pack(anchor=tk.W, padx=10)
        
        add_setting(scrollable_frame, "Distance (mm):", "retraction_distance", 
                   self.printer_config.retraction_distance, 'float')
        add_setting(scrollable_frame, "Speed (mm/s):", "retraction_speed", 
                   self.printer_config.retraction_speed, 'float')
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        ttk.Label(scrollable_frame, text="Speeds (mm/s):", 
                 font=('TkDefaultFont', 10, 'bold')).pack(anchor=tk.W, padx=10)
        
        add_setting(scrollable_frame, "Travel Speed:", "travel_speed", 
                   self.printer_config.travel_speed, 'float')
        add_setting(scrollable_frame, "Print Speed:", "print_speed", 
                   self.printer_config.print_speed, 'float')
        add_setting(scrollable_frame, "First Layer Speed:", "first_layer_speed", 
                   self.printer_config.first_layer_speed, 'float')
        
        ttk.Separator(scrollable_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        ttk.Label(scrollable_frame, text="Other Settings:", 
                 font=('TkDefaultFont', 10, 'bold')).pack(anchor=tk.W, padx=10)
        
        add_setting(scrollable_frame, "Z Offset (mm):", "z_offset", 
                   self.printer_config.z_offset, 'float')
        add_setting(scrollable_frame, "Use Bed Leveling:", "use_bed_leveling", 
                   self.printer_config.use_bed_leveling, 'bool')
        add_setting(scrollable_frame, "Bed Leveling Command:", "bed_leveling_command", 
                   self.printer_config.bed_leveling_command, 'str')
        add_setting(scrollable_frame, "Home Command:", "home_command", 
                   self.printer_config.home_command, 'str')
        add_setting(scrollable_frame, "Fan Speed (0-255):", "fan_speed", 
                   self.printer_config.fan_speed, 'int')
        add_setting(scrollable_frame, "Enable Fan at Layer:", "enable_fan_layer", 
                   self.printer_config.enable_fan_layer, 'int')
        
        # Buttons
        button_frame = ttk.Frame(scrollable_frame)
        button_frame.pack(pady=20)
        
        def save_settings():
            try:
                for key, (var, var_type) in settings.items():
                    value = var.get()
                    if var_type == 'float':
                        value = float(value)
                    elif var_type == 'int':
                        value = int(value)
                    elif var_type == 'bool':
                        value = bool(value)
                    setattr(self.printer_config, key, value)
                
                self.config_label.config(text=f"Config: {self.printer_config.printer_name}")
                messagebox.showinfo("Success", "Settings updated!")
                settings_window.destroy()
            except ValueError as e:
                messagebox.showerror("Error", f"Invalid value: {str(e)}")
        
        ttk.Button(button_frame, text="Save", command=save_settings).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancel", command=settings_window.destroy).pack(side=tk.LEFT, padx=5)
        
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
    def generate_gcode(self):
        """Generate G-code file"""
        filename = filedialog.asksaveasfilename(
            defaultextension=".gcode",
            filetypes=[("G-code files", "*.gcode"), ("All files", "*.*")],
            initialfile=f"print_{self.pattern_type.get()}.gcode"
        )
        
        if not filename:
            return
        
        self.status_bar.config(text="Generating G-code...")
        self.root.update_idletasks()
        
        gcode_gen = GCodeGenerator(self.printer_config)
        gcode_lines = []
        
        # Add header
        gcode_lines.extend(gcode_gen.generate_header(
            self.nozzle_diameter.get(), self.layer_height.get(), 
            self.extrusion_width.get(), self.pattern_type.get(), self.shape_type.get()
        ))
        
        # Generate layers
        for layer_num in range(self.num_layers.get()):
            layer_z = layer_num * self.layer_height.get()
            
            gcode_lines.append(f"; Layer {layer_num + 1}/{self.num_layers.get()}")
            gcode_lines.append(f"; Z = {layer_z:.3f}mm")
            
            if layer_num == self.printer_config.enable_fan_layer:
                gcode_lines.append(f"M106 S{self.printer_config.fan_speed} ; Enable fan")
            
            points = self.generate_path_points(self.shape_type.get(), layer_z, self.pattern_type.get())
            
            if len(points) == 0:
                continue
            
            if layer_num == 0:
                feed_rate = self.printer_config.first_layer_speed
            else:
                feed_rate = self.printer_config.print_speed
            
            first_point = True
            previous_valid = False
            
            for i, point in enumerate(points):
                is_valid = not np.any(np.isnan(point))
                
                if is_valid:
                    x, y, z = point
                    
                    if first_point or not previous_valid:
                        gcode_lines.extend(
                            gcode_gen.move_to(x, y, z, self.printer_config.travel_speed, 
                                            extrude=False)
                        )
                        first_point = False
                    else:
                        gcode_lines.extend(
                            gcode_gen.move_to(x, y, z, feed_rate, extrude=True,
                                            layer_height=self.layer_height.get(),
                                            extrusion_width=self.extrusion_width.get())
                        )
                    
                    previous_valid = True
                else:
                    previous_valid = False
            
            gcode_lines.append("")
        
        # Add footer
        gcode_lines.extend(gcode_gen.generate_footer())
        
        # Write to file
        try:
            with open(filename, 'w') as f:
                f.write('\n'.join(gcode_lines))
            
            est_height = self.num_layers.get() * self.layer_height.get()
            
            result_msg = f"G-code generated successfully!\n\n"
            result_msg += f"File: {os.path.basename(filename)}\n"
            result_msg += f"Lines: {len(gcode_lines)}\n"
            result_msg += f"Layers: {self.num_layers.get()}\n"
            result_msg += f"Height: {est_height:.2f}mm\n"
            result_msg += f"Printer: {self.printer_config.printer_name}\n\n"
            result_msg += "‚ö†Ô∏è ALWAYS preview G-code before printing!"
            
            messagebox.showinfo("G-Code Generated", result_msg)
            self.status_bar.config(text="G-code generated successfully")
        except Exception as e:
            messagebox.showerror("Error", f"Could not save G-code:\n{str(e)}")
            self.status_bar.config(text="Error generating G-code")

def main():
    root = tk.Tk()
    app = PrintSimulator(root)
    root.mainloop()

if __name__ == "__main__":
    main()
